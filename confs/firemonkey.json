{
  "autoUpdateInterval": 0,
  "autoUpdateLast": 0,
  "cmOptions": "",
  "counter": true,
  "customOptionsCSS": "",
  "customPopupCSS": "",
  "globalScriptExcludeMatches": "",
  "sync": false,
  "template": {
    "css": "",
    "js": ""
  },
  "_FrankerFaceZ": {
    "name": "FrankerFaceZ",
    "author": "",
    "description": "FrankerFaceZ gives Twitch users custom chat emotes and introduces new features to improve the viewing experience.",
    "version": "1.58",
    "updateURL": "https://cdn.frankerfacez.com/script/ffz_injector.user.js",
    "metaURL": "",
    "preprocessor": "",
    "injectInto": "",
    "runAt": "document_end",
    "allFrames": false,
    "matchAboutBlank": false,
    "antifeatures": [],
    "container": [],
    "excludes": [],
    "includes": [],
    "require": [],
    "resource": {},
    "matches": [
      "http://twitch.tv/*",
      "https://twitch.tv/*",
      "http://*.twitch.tv/*",
      "https://*.twitch.tv/*"
    ],
    "excludeMatches": [
      "http://api.twitch.tv/*",
      "https://api.twitch.tv/*"
    ],
    "includeGlobs": [],
    "excludeGlobs": [],
    "grant": [
      "none"
    ],
    "i18n": {
      "name": {},
      "description": {}
    },
    "storage": {},
    "userMeta": "",
    "userVar": {},
    "autoUpdate": false,
    "enabled": true,
    "error": "",
    "requireRemote": [],
    "style": [],
    "js": "// ==UserScript==\n// @id\t\t\tfrankerfacez\n// @name\t\tFrankerFaceZ\n// @namespace\tFrankerFaceZ\n//\n// @version\t\t1.58\n// @updateURL\thttps://cdn.frankerfacez.com/script/ffz_injector.user.js\n//\n// @description\tFrankerFaceZ gives Twitch users custom chat emotes and introduces new features to improve the viewing experience.\n// @homepage\thttps://www.frankerfacez.com/\n// @icon\t\thttps://cdn.frankerfacez.com/script/icon32.png\n// @icon64\t\thttps://cdn.frankerfacez.com/script/icon64.png\n// @icon128\t\thttps://cdn.frankerfacez.com/script/icon128.png\n//\n// @include\t\thttp://twitch.tv/*\n// @include\t\thttps://twitch.tv/*\n// @include\t\thttp://*.twitch.tv/*\n// @include\t\thttps://*.twitch.tv/*\n//\n// @exclude\t\thttp://api.twitch.tv/*\n// @exclude\t\thttps://api.twitch.tv/*\n//\n// @grant\t\tnone\n// @run-at\t\tdocument-end\n// ==/UserScript==\n\nfunction ffz_init()\n{\n\tvar script = document.createElement('script');\n\n\tscript.id = 'ffz_script';\n\tscript.type = 'text/javascript';\n\tscript.src = '//cdn.frankerfacez.com/script/script.min.js?_=' + Date.now();\n\n\tif ( localStorage.ffzDebugMode == \"true\" ) {\n\t\t// Developer Mode is enabled. But is the server running? Check before\n\t\t// we include the script, otherwise someone could break their\n\t\t// experience and not be able to recover.\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open(\"GET\", \"//localhost:8000/dev_server\", true);\n\t\txhr.onload = function(e) {\n\t\t\tvar resp = JSON.parse(xhr.responseText);\n\t\t\tconsole.log(\"FFZ: Development Server is present. Version \" + resp.version + \" running from: \" + resp.path);\n\t\t\tscript.src = \"//localhost:8000/script/script.js?_=\" + Date.now();\n\t\t\tdocument.body.classList.add(\"ffz-dev\");\n\t\t\tdocument.head.appendChild(script);\n\t\t};\n\t\txhr.onerror = function(e) {\n\t\t\tconsole.log(\"FFZ: Development Server is not present. Using CDN.\");\n\t\t\tdocument.head.appendChild(script);\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n\n\tdocument.head.appendChild(script);\n}\n\nffz_init();",
    "css": ""
  },
  "_TwitchAdSolutions (video-swap-new)": {
    "name": "TwitchAdSolutions (video-swap-new)",
    "author": "pixeltris",
    "description": "Multiple solutions for blocking Twitch ads (video-swap-new)",
    "version": "1.24",
    "updateURL": "https://github.com/pixeltris/TwitchAdSolutions/raw/master/video-swap-new/video-swap-new.user.js",
    "metaURL": "",
    "preprocessor": "",
    "injectInto": "page",
    "runAt": "document_start",
    "allFrames": false,
    "matchAboutBlank": false,
    "antifeatures": [],
    "container": [],
    "excludes": [],
    "includes": [],
    "require": [],
    "resource": {},
    "matches": [
      "*://*.twitch.tv/*"
    ],
    "excludeMatches": [],
    "includeGlobs": [],
    "excludeGlobs": [],
    "grant": [
      "none"
    ],
    "i18n": {
      "name": {},
      "description": {}
    },
    "storage": {},
    "userMeta": "",
    "userVar": {},
    "autoUpdate": false,
    "enabled": true,
    "error": "",
    "requireRemote": [],
    "style": [],
    "js": "// ==UserScript==\n// @name         TwitchAdSolutions (video-swap-new)\n// @namespace    https://github.com/pixeltris/TwitchAdSolutions\n// @version      1.24\n// @updateURL    https://github.com/pixeltris/TwitchAdSolutions/raw/master/video-swap-new/video-swap-new.user.js\n// @downloadURL  https://github.com/pixeltris/TwitchAdSolutions/raw/master/video-swap-new/video-swap-new.user.js\n// @description  Multiple solutions for blocking Twitch ads (video-swap-new)\n// @author       pixeltris\n// @match        *://*.twitch.tv/*\n// @run-at       document-start\n// @inject-into  page\n// @grant        none\n// ==/UserScript==\n(function() {\n    'use strict';\n    function declareOptions(scope) {\n        // Options / globals\n        scope.OPT_ROLLING_DEVICE_ID = false;\n        scope.OPT_MODE_STRIP_AD_SEGMENTS = true;\n        scope.OPT_MODE_NOTIFY_ADS_WATCHED = true;\n        scope.OPT_MODE_NOTIFY_ADS_WATCHED_MIN_REQUESTS = false;\n        scope.OPT_BACKUP_PLAYER_TYPE = 'autoplay';\n        scope.OPT_BACKUP_PLATFORM = 'ios';\n        scope.OPT_REGULAR_PLAYER_TYPE = 'site';\n        scope.OPT_ACCESS_TOKEN_PLAYER_TYPE = null;\n        scope.OPT_SHOW_AD_BANNER = true;\n        scope.AD_SIGNIFIER = 'stitched-ad';\n        scope.LIVE_SIGNIFIER = ',live';\n        scope.CLIENT_ID = 'kimne78kx3ncx6brgo4mv6wki5h1ko';\n        // These are only really for Worker scope...\n        scope.StreamInfos = [];\n        scope.StreamInfosByUrl = [];\n        scope.CurrentChannelNameFromM3U8 = null;\n        // Need this in both scopes. Window scope needs to update this to worker scope.\n        scope.gql_device_id = null;\n        scope.gql_device_id_rolling = '';\n        // Rolling device id crap... TODO: improve this\n        var charTable = []; for (var i = 97; i <= 122; i++) { charTable.push(String.fromCharCode(i)); } for (var i = 65; i <= 90; i++) { charTable.push(String.fromCharCode(i)); } for (var i = 48; i <= 57; i++) { charTable.push(String.fromCharCode(i)); }\n        var bs = 'eVI6jx47kJvCFfFowK86eVI6jx47kJvC';\n        var di = (new Date()).getUTCFullYear() + (new Date()).getUTCMonth() + ((new Date()).getUTCDate() / 7) | 0;\n        for (var i = 0; i < bs.length; i++) {\n            scope.gql_device_id_rolling += charTable[(bs.charCodeAt(i) ^ di) % charTable.length];\n        }\n        scope.gql_device_id_rolling = '1';//temporary\n        scope.ClientIntegrityHeader = null;\n        scope.AuthorizationHeader = null;\n    }\n    declareOptions(window);\n    var twitchWorkers = [];\n    const oldWorker = window.Worker;\n    window.Worker = class Worker extends oldWorker {\n        constructor(twitchBlobUrl) {\n            var jsURL = getWasmWorkerUrl(twitchBlobUrl);\n            if (typeof jsURL !== 'string') {\n                super(twitchBlobUrl);\n                return;\n            }\n            var newBlobStr = `\n                ${processM3U8.toString()}\n                ${hookWorkerFetch.toString()}\n                ${declareOptions.toString()}\n                ${getAccessToken.toString()}\n                ${gqlRequest.toString()}\n                ${makeGraphQlPacket.toString()}\n                ${tryNotifyAdsWatchedM3U8.toString()}\n                ${parseAttributes.toString()}\n                ${onFoundAd.toString()}\n                declareOptions(self);\n                self.addEventListener('message', function(e) {\n                    if (e.data.key == 'UboUpdateDeviceId') {\n                        gql_device_id = e.data.value;\n                    } else if (e.data.key == 'UpdateClientIntegrityHeader') {\n                        ClientIntegrityHeader = e.data.value;\n                    } else if (e.data.key == 'UpdateAuthorizationHeader') {\n                        AuthorizationHeader = e.data.value;\n                    }\n                });\n                hookWorkerFetch();\n                importScripts('${jsURL}');\n            `\n            super(URL.createObjectURL(new Blob([newBlobStr])));\n            twitchWorkers.push(this);\n            this.onmessage = function(e) {\n                // NOTE: Removed adDiv caching as '.video-player' can change between streams?\n                if (e.data.key == 'UboShowAdBanner') {\n                    var adDiv = getAdDiv();\n                    if (adDiv != null) {\n                        adDiv.P.textContent = 'Blocking' + (e.data.isMidroll ? ' midroll' : '') + ' ads';\n                        if (OPT_SHOW_AD_BANNER) {\n                            adDiv.style.display = 'block';\n                        }\n                    }\n                } else if (e.data.key == 'UboHideAdBanner') {\n                    var adDiv = getAdDiv();\n                    if (adDiv != null) {\n                        adDiv.style.display = 'none';\n                    }\n                } else if (e.data.key == 'UboChannelNameM3U8Changed') {\n                    //console.log('M3U8 channel name changed to ' + e.data.value);\n                } else if (e.data.key == 'UboReloadPlayer') {\n                    reloadTwitchPlayer();\n                } else if (e.data.key == 'UboPauseResumePlayer') {\n                    reloadTwitchPlayer(false, true);\n                } else if (e.data.key == 'UboSeekPlayer') {\n                    reloadTwitchPlayer(true);\n                }\n            }\n            function getAdDiv() {\n                var playerRootDiv = document.querySelector('.video-player');\n                var adDiv = null;\n                if (playerRootDiv != null) {\n                    adDiv = playerRootDiv.querySelector('.ubo-overlay');\n                    if (adDiv == null) {\n                        adDiv = document.createElement('div');\n                        adDiv.className = 'ubo-overlay';\n                        adDiv.innerHTML = '<div class=\"player-ad-notice\" style=\"color: white; background-color: rgba(0, 0, 0, 0.8); position: absolute; top: 0px; left: 0px; padding: 5px;\"><p></p></div>';\n                        adDiv.style.display = 'none';\n                        adDiv.P = adDiv.querySelector('p');\n                        playerRootDiv.appendChild(adDiv);\n                    }\n                }\n                return adDiv;\n            }\n        }\n    }\n    function getWasmWorkerUrl(twitchBlobUrl) {\n        var req = new XMLHttpRequest();\n        req.open('GET', twitchBlobUrl, false);\n        req.send();\n        return req.responseText.split(\"'\")[1];\n    }\n    function onFoundAd(streamInfo, textStr, reloadPlayer) {\n        console.log('Found ads, switch to backup');\n        streamInfo.UseBackupStream = true;\n        streamInfo.IsMidroll = textStr.includes('\"MIDROLL\"') || textStr.includes('\"midroll\"');\n        if (reloadPlayer) {\n            postMessage({key:'UboReloadPlayer'});\n        }\n        postMessage({key:'UboShowAdBanner',isMidroll:streamInfo.IsMidroll});\n    }\n    async function processM3U8(url, textStr, realFetch) {\n        var streamInfo = StreamInfosByUrl[url];\n        if (streamInfo == null) {\n            console.log('Unknown stream url ' + url);\n            //postMessage({key:'UboHideAdBanner'});\n            return textStr;\n        }\n        if (!OPT_MODE_STRIP_AD_SEGMENTS) {\n            return textStr;\n        }\n        var haveAdTags = textStr.includes(AD_SIGNIFIER);\n        if (streamInfo.UseBackupStream) {\n            if (streamInfo.Encodings == null) {\n                console.log('Found backup stream but not main stream?');\n                streamInfo.UseBackupStream = false;\n                postMessage({key:'UboReloadPlayer'});\n                return '';\n            } else {\n                var streamM3u8Url = streamInfo.Encodings.match(/^https:.*\\.m3u8$/m)[0];\n                var streamM3u8Response = await realFetch(streamM3u8Url);\n                if (streamM3u8Response.status == 200) {\n                    var streamM3u8 = await streamM3u8Response.text();\n                    if (streamM3u8 != null) {\n                        if (!streamM3u8.includes(AD_SIGNIFIER)) {\n                            console.log('No more ads on main stream. Triggering player reload to go back to main stream...');\n                            streamInfo.UseBackupStream = false;\n                            postMessage({key:'UboHideAdBanner'});\n                            postMessage({key:'UboReloadPlayer'});\n                        } else if (!streamM3u8.includes('\"MIDROLL\"') && !streamM3u8.includes('\"midroll\"')) {\n                            var lines = streamM3u8.replace('\\r', '').split('\\n');\n                            for (var i = 0; i < lines.length; i++) {\n                                var line = lines[i];\n                                if (line.startsWith('#EXTINF') && lines.length > i + 1) {\n                                    if (!line.includes(LIVE_SIGNIFIER) && !streamInfo.RequestedAds.has(lines[i + 1])) {\n                                        // Only request one .ts file per .m3u8 request to avoid making too many requests\n                                        //console.log('Fetch ad .ts file');\n                                        streamInfo.RequestedAds.add(lines[i + 1]);\n                                        fetch(lines[i + 1]).then((response)=>{response.blob()});\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (streamInfo.BackupEncodings == null) {\n                return '';\n            }\n        } else if (haveAdTags) {\n            onFoundAd(streamInfo, textStr, true);\n            return '';\n        } else {\n            postMessage({key:'UboHideAdBanner'});\n        }\n        return textStr;\n    }\n    function hookWorkerFetch() {\n        console.log('hookWorkerFetch');\n        var realFetch = fetch;\n        fetch = async function(url, options) {\n            if (typeof url === 'string') {\n                url = url.trimEnd();\n                if (url.endsWith('m3u8')) {\n                    return new Promise(function(resolve, reject) {\n                        var processAfter = async function(response) {\n                            var str = await processM3U8(url, await response.text(), realFetch);\n                            resolve(new Response(str));\n                        };\n                        var send = function() {\n                            return realFetch(url, options).then(function(response) {\n                                processAfter(response);\n                            })['catch'](function(err) {\n                                console.log('fetch hook err ' + err);\n                                reject(err);\n                            });\n                        };\n                        send();\n                    });\n                }\n                else if (url.includes('/api/channel/hls/') && !url.includes('picture-by-picture')) {\n                    var channelName = (new URL(url)).pathname.match(/([^\\/]+)(?=\\.\\w+$)/)[0];\n                    if (CurrentChannelNameFromM3U8 != channelName) {\n                        postMessage({\n                            key: 'UboChannelNameM3U8Changed',\n                            value: channelName\n                        });\n                    }\n                    CurrentChannelNameFromM3U8 = channelName;\n                    if (OPT_MODE_STRIP_AD_SEGMENTS) {\n                        return new Promise(async function(resolve, reject) {\n                            // - First m3u8 request is the m3u8 with the video encodings (360p,480p,720p,etc).\n                            // - Second m3u8 request is the m3u8 for the given encoding obtained in the first request. At this point we will know if there's ads.\n                            var streamInfo = StreamInfos[channelName];\n                            var useBackupStream = false;\n                            if (streamInfo == null || streamInfo.Encodings == null || streamInfo.BackupEncodings == null) {\n                                StreamInfos[channelName] = streamInfo = {\n                                    RequestedAds: new Set(),\n                                    Encodings: null,\n                                    BackupEncodings: null,\n                                    IsMidroll: false,\n                                    UseBackupStream: false,\n                                    ChannelName: channelName\n                                };\n                                for (var i = 0; i < 2; i++) {\n                                    var encodingsUrl = url;\n                                    if (i == 1) {\n                                        var accessTokenResponse = await getAccessToken(channelName, OPT_BACKUP_PLAYER_TYPE, OPT_BACKUP_PLATFORM, realFetch);\n                                        if (accessTokenResponse != null && accessTokenResponse.status === 200) {\n                                            var accessToken = await accessTokenResponse.json();\n                                            var urlInfo = new URL('https://usher.ttvnw.net/api/channel/hls/' + channelName + '.m3u8' + (new URL(url)).search);\n                                            urlInfo.searchParams.set('sig', accessToken.data.streamPlaybackAccessToken.signature);\n                                            urlInfo.searchParams.set('token', accessToken.data.streamPlaybackAccessToken.value);\n                                            encodingsUrl = urlInfo.href;\n                                        } else {\n                                            resolve(accessTokenResponse);\n                                            return;\n                                        }\n                                    }\n                                    var encodingsM3u8Response = await realFetch(encodingsUrl, options);\n                                    if (encodingsM3u8Response != null && encodingsM3u8Response.status === 200) {\n                                        var encodingsM3u8 = await encodingsM3u8Response.text();\n                                        if (i == 0) {\n                                            streamInfo.Encodings = encodingsM3u8;\n                                            var streamM3u8Url = encodingsM3u8.match(/^https:.*\\.m3u8$/m)[0];\n                                            var streamM3u8Response = await realFetch(streamM3u8Url);\n                                            if (streamM3u8Response.status == 200) {\n                                                var streamM3u8 = await streamM3u8Response.text();\n                                                if (streamM3u8.includes(AD_SIGNIFIER)) {\n                                                    onFoundAd(streamInfo, streamM3u8, false);\n                                                }\n                                            } else {\n                                                resolve(streamM3u8Response);\n                                                return;\n                                            }\n                                        } else {\n                                            var lowResLines = encodingsM3u8.replace('\\r', '').split('\\n');\n                                            var lowResBestUrl = null;\n                                            for (var j = 0; j < lowResLines.length; j++) {\n                                                if (lowResLines[j].startsWith('#EXT-X-STREAM-INF')) {\n                                                    var res = parseAttributes(lowResLines[j])['RESOLUTION'];\n                                                    if (res && lowResLines[j + 1].endsWith('.m3u8')) {\n                                                        // Assumes resolutions are correctly ordered\n                                                        lowResBestUrl = lowResLines[j + 1];\n                                                        break;\n                                                    }\n                                                }\n                                            }\n                                            if (lowResBestUrl != null && streamInfo.Encodings != null) {\n                                                var normalEncodingsM3u8 = streamInfo.Encodings;\n                                                var normalLines = normalEncodingsM3u8.replace('\\r', '').split('\\n');\n                                                for (var j = 0; j < normalLines.length - 1; j++) {\n                                                    if (normalLines[j].startsWith('#EXT-X-STREAM-INF')) {\n                                                        var res = parseAttributes(normalLines[j])['RESOLUTION'];\n                                                        if (res) {\n                                                            lowResBestUrl += ' ';// The stream doesn't load unless each url line is unique\n                                                            normalLines[j + 1] = lowResBestUrl;\n                                                        }\n                                                    }\n                                                }\n                                                encodingsM3u8 = normalLines.join('\\r\\n');\n                                            }\n                                            streamInfo.BackupEncodings = encodingsM3u8;\n                                        }\n                                        var lines = encodingsM3u8.replace('\\r', '').split('\\n');\n                                        for (var j = 0; j < lines.length; j++) {\n                                            if (!lines[j].startsWith('#') && lines[j].includes('.m3u8')) {\n                                                StreamInfosByUrl[lines[j].trimEnd()] = streamInfo;\n                                            }\n                                        }\n                                    } else {\n                                        resolve(encodingsM3u8Response);\n                                        return;\n                                    }\n                                }\n                            }\n                            if (streamInfo.UseBackupStream) {\n                                resolve(new Response(streamInfo.BackupEncodings));\n                            } else {\n                                resolve(new Response(streamInfo.Encodings));\n                            }\n                        });\n                    }\n                }\n            }\n            return realFetch.apply(this, arguments);\n        }\n    }\n    function makeGraphQlPacket(event, radToken, payload) {\n        return [{\n            operationName: 'ClientSideAdEventHandling_RecordAdEvent',\n            variables: {\n                input: {\n                    eventName: event,\n                    eventPayload: JSON.stringify(payload),\n                    radToken,\n                },\n            },\n            extensions: {\n                persistedQuery: {\n                    version: 1,\n                    sha256Hash: '7e6c69e6eb59f8ccb97ab73686f3d8b7d85a72a0298745ccd8bfc68e4054ca5b',\n                },\n            },\n        }];\n    }\n    function getAccessToken(channelName, playerType, platform, realFetch) {\n        if (!platform) {\n            platform = 'web';\n        }\n        var body = null;\n        var templateQuery = 'query PlaybackAccessToken_Template($login: String!, $isLive: Boolean!, $vodID: ID!, $isVod: Boolean!, $playerType: String!) {  streamPlaybackAccessToken(channelName: $login, params: {platform: \"' + platform + '\", playerBackend: \"mediaplayer\", playerType: $playerType}) @include(if: $isLive) {    value    signature    __typename  }  videoPlaybackAccessToken(id: $vodID, params: {platform: \"' + platform + '\", playerBackend: \"mediaplayer\", playerType: $playerType}) @include(if: $isVod) {    value    signature    __typename  }}';\n        body = {\n            operationName: 'PlaybackAccessToken_Template',\n            query: templateQuery,\n            variables: {\n                'isLive': true,\n                'login': channelName,\n                'isVod': false,\n                'vodID': '',\n                'playerType': playerType\n            }\n        };\n        return gqlRequest(body, realFetch);\n    }\n    function gqlRequest(body, realFetch) {\n        if (ClientIntegrityHeader == null) {\n            //console.warn('ClientIntegrityHeader is null');\n            //throw 'ClientIntegrityHeader is null';\n        }\n        var fetchFunc = realFetch ? realFetch : fetch;\n        return fetchFunc('https://gql.twitch.tv/gql', {\n            method: 'POST',\n            body: JSON.stringify(body),\n            headers: {\n                'Client-Id': CLIENT_ID,\n                'Client-Integrity': ClientIntegrityHeader,\n                'X-Device-Id': OPT_ROLLING_DEVICE_ID ? gql_device_id_rolling : gql_device_id,\n                'Authorization': AuthorizationHeader\n            }\n        });\n    }\n    function parseAttributes(str) {\n        return Object.fromEntries(\n            str.split(/(?:^|,)((?:[^=]*)=(?:\"[^\"]*\"|[^,]*))/)\n                .filter(Boolean)\n                .map(x => {\n                    const idx = x.indexOf('=');\n                    const key = x.substring(0, idx);\n                    const value = x.substring(idx +1);\n                    const num = Number(value);\n                    return [key, Number.isNaN(num) ? value.startsWith('\"') ? JSON.parse(value) : value : num]\n                }));\n    }\n    async function tryNotifyAdsWatchedM3U8(streamM3u8) {\n        try {\n            //console.log(streamM3u8);\n            if (!streamM3u8 || !streamM3u8.includes(AD_SIGNIFIER)) {\n                return 1;\n            }\n            var matches = streamM3u8.match(/#EXT-X-DATERANGE:(ID=\"stitched-ad-[^\\n]+)\\n/);\n            if (matches.length > 1) {\n                const attrString = matches[1];\n                const attr = parseAttributes(attrString);\n                var podLength = parseInt(attr['X-TV-TWITCH-AD-POD-LENGTH'] ? attr['X-TV-TWITCH-AD-POD-LENGTH'] : '1');\n                var podPosition = parseInt(attr['X-TV-TWITCH-AD-POD-POSITION'] ? attr['X-TV-TWITCH-AD-POD-POSITION'] : '0');\n                var radToken = attr['X-TV-TWITCH-AD-RADS-TOKEN'];\n                var lineItemId = attr['X-TV-TWITCH-AD-LINE-ITEM-ID'];\n                var orderId = attr['X-TV-TWITCH-AD-ORDER-ID'];\n                var creativeId = attr['X-TV-TWITCH-AD-CREATIVE-ID'];\n                var adId = attr['X-TV-TWITCH-AD-ADVERTISER-ID'];\n                var rollType = attr['X-TV-TWITCH-AD-ROLL-TYPE'].toLowerCase();\n                const baseData = {\n                    stitched: true,\n                    roll_type: rollType,\n                    player_mute: false,\n                    player_volume: 0.5,\n                    visible: true,\n                };\n                for (let podPosition = 0; podPosition < podLength; podPosition++) {\n                    if (OPT_MODE_NOTIFY_ADS_WATCHED_MIN_REQUESTS) {\n                        // This is all that's actually required at the moment\n                        await gqlRequest(makeGraphQlPacket('video_ad_pod_complete', radToken, baseData));\n                    } else {\n                        const extendedData = {\n                            ...baseData,\n                            ad_id: adId,\n                            ad_position: podPosition,\n                            duration: 30,\n                            creative_id: creativeId,\n                            total_ads: podLength,\n                            order_id: orderId,\n                            line_item_id: lineItemId,\n                        };\n                        await gqlRequest(makeGraphQlPacket('video_ad_impression', radToken, extendedData));\n                        for (let quartile = 0; quartile < 4; quartile++) {\n                            await gqlRequest(\n                                makeGraphQlPacket('video_ad_quartile_complete', radToken, {\n                                    ...extendedData,\n                                    quartile: quartile + 1,\n                                })\n                            );\n                        }\n                        await gqlRequest(makeGraphQlPacket('video_ad_pod_complete', radToken, baseData));\n                    }\n                }\n            }\n            return 0;\n        } catch (err) {\n            console.log(err);\n            return 0;\n        }\n    }\n    function postTwitchWorkerMessage(key, value) {\n        twitchWorkers.forEach((worker) => {\n            worker.postMessage({key: key, value: value});\n        });\n    }\n    function hookFetch() {\n        var realFetch = window.fetch;\n        window.fetch = function(url, init, ...args) {\n            if (typeof url === 'string') {\n                if (url.includes('gql')) {\n                    var deviceId = init.headers['X-Device-Id'];\n                    if (typeof deviceId !== 'string') {\n                        deviceId = init.headers['Device-ID'];\n                    }\n                    if (typeof deviceId === 'string') {\n                        gql_device_id = deviceId;\n                    }\n                    if (gql_device_id) {\n                        postTwitchWorkerMessage('UboUpdateDeviceId', gql_device_id);\n                    }\n                    if (typeof init.body === 'string' && init.body.includes('PlaybackAccessToken')) {\n                        if (OPT_ACCESS_TOKEN_PLAYER_TYPE) {\n                            const newBody = JSON.parse(init.body);\n                            if (Array.isArray(newBody)) {\n                                for (let i = 0; i < newBody.length; i++) {\n                                    newBody[i].variables.playerType = OPT_ACCESS_TOKEN_PLAYER_TYPE;\n                                }\n                            } else {\n                                newBody.variables.playerType = OPT_ACCESS_TOKEN_PLAYER_TYPE;\n                            }\n                            init.body = JSON.stringify(newBody);\n                        }\n                        if (OPT_ROLLING_DEVICE_ID) {\n                            if (typeof init.headers['X-Device-Id'] === 'string') {\n                                init.headers['X-Device-Id'] = gql_device_id_rolling;\n                            }\n                            if (typeof init.headers['Device-ID'] === 'string') {\n                                init.headers['Device-ID'] = gql_device_id_rolling;\n                            }\n                        }\n                        if (typeof init.headers['Client-Integrity'] === 'string') {\n                            ClientIntegrityHeader = init.headers['Client-Integrity'];\n                            if (ClientIntegrityHeader) {\n                                postTwitchWorkerMessage('UpdateClientIntegrityHeader', init.headers['Client-Integrity']);\n                            }\n                        }\n                        if (typeof init.headers['Authorization'] === 'string') {\n                            AuthorizationHeader = init.headers['Authorization'];\n                            if (AuthorizationHeader) {\n                                postTwitchWorkerMessage('UpdateAuthorizationHeader', init.headers['Authorization']);\n                            }\n                        }\n                    }\n                }\n            }\n            return realFetch.apply(this, arguments);\n        };\n    }\n    function reloadTwitchPlayer(isSeek, isPausePlay) {\n        // Taken from ttv-tools / ffz\n        // https://github.com/Nerixyz/ttv-tools/blob/master/src/context/twitch-player.ts\n        // https://github.com/FrankerFaceZ/FrankerFaceZ/blob/master/src/sites/twitch-twilight/modules/player.jsx\n        function findReactNode(root, constraint) {\n            if (root.stateNode && constraint(root.stateNode)) {\n                return root.stateNode;\n            }\n            let node = root.child;\n            while (node) {\n                const result = findReactNode(node, constraint);\n                if (result) {\n                    return result;\n                }\n                node = node.sibling;\n            }\n            return null;\n        }\n        function findReactRootNode() {\n            var reactRootNode = null;\n            var rootNode = document.querySelector('#root');\n            if (rootNode && rootNode._reactRootContainer && rootNode._reactRootContainer._internalRoot && rootNode._reactRootContainer._internalRoot.current) {\n                reactRootNode = rootNode._reactRootContainer._internalRoot.current;\n            }\n            if (reactRootNode == null) {\n                var containerName = Object.keys(rootNode).find(x => x.startsWith('__reactContainer'));\n                if (containerName != null) {\n                    reactRootNode = rootNode[containerName];\n                }\n            }\n            return reactRootNode;\n        }\n        var reactRootNode = findReactRootNode();\n        if (!reactRootNode) {\n            console.log('Could not find react root');\n            return;\n        }\n        var player = findReactNode(reactRootNode, node => node.setPlayerActive && node.props && node.props.mediaPlayerInstance);\n        player = player && player.props && player.props.mediaPlayerInstance ? player.props.mediaPlayerInstance : null;\n        var playerState = findReactNode(reactRootNode, node => node.setSrc && node.setInitialPlaybackSettings);\n        if (!player) {\n            console.log('Could not find player');\n            return;\n        }\n        if (!playerState) {\n            console.log('Could not find player state');\n            return;\n        }\n        if (player.paused || player.core?.paused) {\n            return;\n        }\n        if (isSeek) {\n            console.log('Force seek to reset player (hopefully fixing any audio desync) pos:' + player.getPosition() + ' range:' + JSON.stringify(player.getBuffered()));\n            var pos = player.getPosition();\n            player.seekTo(0);\n            player.seekTo(pos);\n            return;\n        }\n        if (isPausePlay) {\n            player.pause();\n            player.play();\n            return;\n        }\n        const lsKeyQuality = 'video-quality';\n        const lsKeyMuted = 'video-muted';\n        const lsKeyVolume = 'volume';\n        var currentQualityLS = localStorage.getItem(lsKeyQuality);\n        var currentMutedLS = localStorage.getItem(lsKeyMuted);\n        var currentVolumeLS = localStorage.getItem(lsKeyVolume);\n        if (player?.core?.state) {\n            localStorage.setItem(lsKeyMuted, JSON.stringify({default:player.core.state.muted}));\n            localStorage.setItem(lsKeyVolume, player.core.state.volume);\n        }\n        if (player?.core?.state?.quality?.group) {\n            localStorage.setItem(lsKeyQuality, JSON.stringify({default:player.core.state.quality.group}));\n        }\n        playerState.setSrc({ isNewMediaPlayerInstance: true, refreshAccessToken: true });\n        setTimeout(() => {\n            localStorage.setItem(lsKeyQuality, currentQualityLS);\n            localStorage.setItem(lsKeyMuted, currentMutedLS);\n            localStorage.setItem(lsKeyVolume, currentVolumeLS);\n        }, 3000);\n    }\n    window.reloadTwitchPlayer = reloadTwitchPlayer;\n    hookFetch();\n    function onContentLoaded() {\n        // This stops Twitch from pausing the player when in another tab and an ad shows.\n        // Taken from https://github.com/saucettv/VideoAdBlockForTwitch/blob/cefce9d2b565769c77e3666ac8234c3acfe20d83/chrome/content.js#L30\n        try {\n            Object.defineProperty(document, 'visibilityState', {\n                get() {\n                    return 'visible';\n                }\n            });\n        }catch{}\n        try {\n            Object.defineProperty(document, 'hidden', {\n                get() {\n                    return false;\n                }\n            });\n        }catch{}\n        var block = e => {\n            e.preventDefault();\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n        };\n        document.addEventListener('visibilitychange', block, true);\n        document.addEventListener('webkitvisibilitychange', block, true);\n        document.addEventListener('mozvisibilitychange', block, true);\n        document.addEventListener('hasFocus', block, true);\n        try {\n            if (/Firefox/.test(navigator.userAgent)) {\n                Object.defineProperty(document, 'mozHidden', {\n                    get() {\n                        return false;\n                    }\n                });\n            } else {\n                Object.defineProperty(document, 'webkitHidden', {\n                    get() {\n                        return false;\n                    }\n                });\n            }\n        }catch{}\n        // Hooks for preserving volume / resolution\n        var keysToCache = [\n            'video-quality',\n            'video-muted',\n            'volume',\n            'lowLatencyModeEnabled',// Low Latency\n            'persistenceEnabled',// Mini Player\n        ];\n        var cachedValues = new Map();\n        for (var i = 0; i < keysToCache.length; i++) {\n            cachedValues.set(keysToCache[i], localStorage.getItem(keysToCache[i]));\n        }\n        var realSetItem = localStorage.setItem;\n        localStorage.setItem = function(key, value) {\n            if (cachedValues.has(key)) {\n                cachedValues.set(key, value);\n            }\n            realSetItem.apply(this, arguments);\n        };\n        var realGetItem = localStorage.getItem;\n        localStorage.getItem = function(key) {\n            if (cachedValues.has(key)) {\n                return cachedValues.get(key);\n            }\n            return realGetItem.apply(this, arguments);\n        };\n    }\n    if (document.readyState === \"complete\" || document.readyState === \"loaded\" || document.readyState === \"interactive\") {\n        onContentLoaded();\n    } else {\n        window.addEventListener(\"DOMContentLoaded\", function() {\n            onContentLoaded();\n        });\n    }\n})();",
    "css": ""
  },
  "_Twitter hide content warning crap": {
    "name": "Twitter hide content warning crap",
    "author": "cromachina",
    "description": "Makes it so nothing is marked as sensitive.",
    "version": "0.14",
    "updateURL": "https://update.greasyfork.org/scripts/437359/Twitter%20hide%20content%20warning%20crap.user.js",
    "metaURL": "https://update.greasyfork.org/scripts/437359/Twitter%20hide%20content%20warning%20crap.meta.js",
    "preprocessor": "",
    "injectInto": "",
    "runAt": "document_idle",
    "allFrames": false,
    "matchAboutBlank": false,
    "antifeatures": [],
    "container": [],
    "excludes": [],
    "includes": [],
    "require": [],
    "resource": {},
    "matches": [
      "https://*.twitter.com/*",
      "https://*.x.com/*"
    ],
    "excludeMatches": [],
    "includeGlobs": [],
    "excludeGlobs": [],
    "grant": [],
    "i18n": {
      "name": {},
      "description": {}
    },
    "storage": {},
    "userMeta": "",
    "userVar": {},
    "autoUpdate": false,
    "enabled": true,
    "error": "",
    "requireRemote": [],
    "style": [],
    "js": "// ==UserScript==\n// @name         Twitter hide content warning crap\n// @namespace    http://tampermonkey.net/\n// @version      0.14\n// @description  Makes it so nothing is marked as sensitive.\n// @author       cromachina\n// @match        https://*.twitter.com/*\n// @match        https://*.x.com/*\n// @icon         https://www.google.com/s2/favicons?domain=twitter.com\n// @license      MIT\n// @downloadURL https://update.greasyfork.org/scripts/437359/Twitter%20hide%20content%20warning%20crap.user.js\n// @updateURL https://update.greasyfork.org/scripts/437359/Twitter%20hide%20content%20warning%20crap.meta.js\n// ==/UserScript==\n/* jshint esversion: 6 */\n\n(function() {\n    let find_objects_at_keys = function(obj, keys)\n    {\n        let found = [];\n        let stack = Object.entries(obj);\n        while (stack.length > 0)\n        {\n            let current = stack.pop();\n            if (keys.includes(current[0]))\n            {\n                found.push(current[1]);\n            }\n            if (current[1] != null && typeof(current[1]) == 'object')\n            {\n                stack = stack.concat(Object.entries(current[1]));\n            }\n        }\n        return found;\n    };\n\n    let fix_media = function(data)\n    {\n        for (let obj of find_objects_at_keys(data, ['media']))\n        {\n            if (!Array.isArray(obj))\n            {\n                continue;\n            }\n            for (let media of obj)\n            {\n                if (typeof media != 'object')\n                {\n                    continue;\n                }\n                delete media.sensitive_media_warning;\n                media.ext_sensitive_media_warning = null;\n            }\n        };\n        for (let obj of find_objects_at_keys(data, ['legacy']))\n        {\n            if (obj != null && obj.hasOwnProperty('possibly_sensitive') && typeof obj.possibly_sensitive == 'boolean')\n            {\n                obj.possibly_sensitive = false;\n            }\n        }\n    };\n\n    // Intercept JSON parses to alter the sensitive media data.\n    let old_parse = unsafeWindow.JSON.parse;\n    let new_parse = function(string)\n    {\n        let data = old_parse(string);\n        try\n        {\n            if (data != null)\n            {\n                fix_media(data);\n            }\n        }\n        catch(error)\n        {\n            console.log(error);\n        }\n        return data;\n    };\n    exportFunction(new_parse, unsafeWindow.JSON, { defineAs: \"parse\" });\n})();\n",
    "css": ""
  }
}